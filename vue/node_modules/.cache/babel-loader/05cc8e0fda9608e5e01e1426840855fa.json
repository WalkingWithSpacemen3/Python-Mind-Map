{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n\n/** \r\n * @Author: 王林 \r\n * @Date: 2021-06-27 13:16:23 \r\n * @Desc: 在下一个事件循环里执行任务 \r\n */\nconst nextTick = function (fn, ctx) {\n  let pending = false;\n  let timerFunc = null;\n\n  let handle = () => {\n    pending = false;\n    ctx ? fn.call(ctx) : fn();\n  }; // 支持MutationObserver接口的话使用MutationObserver\n\n\n  if (typeof MutationObserver !== 'undefined') {\n    let counter = 1;\n    let observer = new MutationObserver(handle);\n    let textNode = document.createTextNode(counter);\n    observer.observe(textNode, {\n      characterData: true // 设为 true 表示监视指定目标节点或子节点树中节点所包含的字符数据的变化\n\n    });\n\n    timerFunc = function () {\n      counter = (counter + 1) % 2; // counter会在0和1两者循环变化\n\n      textNode.data = counter; // 节点变化会触发回调handle，\n    };\n  } else {\n    // 否则使用定时器\n    timerFunc = setTimeout;\n  }\n\n  return function (cb, ctx) {\n    if (pending) return;\n    pending = true;\n    timerFunc(handle, 0);\n  };\n};\n/** \r\n * @Author: 王林 \r\n * @Date: 2021-06-26 22:40:52 \r\n * @Desc: 批量执行 \r\n */\n\n\nclass BatchExecution {\n  /** \r\n   * @Author: 王林 \r\n   * @Date: 2021-06-26 22:41:41 \r\n   * @Desc: 构造函数 \r\n   */\n  constructor() {\n    this.has = {};\n    this.queue = [];\n    this.nextTick = nextTick(this.flush, this);\n  }\n  /** \r\n   * @Author: 王林 \r\n   * @Date: 2021-06-27 12:54:04 \r\n   * @Desc: 添加任务 \r\n   */\n\n\n  push(name, fn) {\n    if (this.has[name]) {\n      return;\n    }\n\n    this.has[name] = true;\n    this.queue.push({\n      name,\n      fn\n    });\n    this.nextTick();\n  }\n  /** \r\n   * @Author: 王林 \r\n   * @Date: 2021-06-27 13:09:24 \r\n   * @Desc:  执行队列\r\n   */\n\n\n  flush() {\n    let fns = this.queue.slice(0);\n    this.queue = [];\n    fns.forEach(({\n      name,\n      fn\n    }) => {\n      this.has[name] = false;\n      fn();\n    });\n  }\n\n}\n\nexport default BatchExecution;","map":{"version":3,"names":["nextTick","fn","ctx","pending","timerFunc","handle","call","MutationObserver","counter","observer","textNode","document","createTextNode","observe","characterData","data","setTimeout","cb","BatchExecution","constructor","has","queue","flush","push","name","fns","slice","forEach"],"sources":["C:/Users/13007/Documents/GinTest/vue/node_modules/simple-mind-map/src/BatchExecution.js"],"sourcesContent":["/** \r\n * @Author: 王林 \r\n * @Date: 2021-06-27 13:16:23 \r\n * @Desc: 在下一个事件循环里执行任务 \r\n */\r\nconst nextTick = function (fn, ctx) {\r\n    let pending = false\r\n    let timerFunc = null\r\n    let handle = () => {\r\n        pending = false\r\n        ctx ? fn.call(ctx) : fn()\r\n    }\r\n    // 支持MutationObserver接口的话使用MutationObserver\r\n    if (typeof MutationObserver !== 'undefined') {\r\n        let counter = 1\r\n        let observer = new MutationObserver(handle)\r\n        let textNode = document.createTextNode(counter)\r\n        observer.observe(textNode, {\r\n            characterData: true// 设为 true 表示监视指定目标节点或子节点树中节点所包含的字符数据的变化\r\n        })\r\n        timerFunc = function () {\r\n            counter = (counter + 1) % 2// counter会在0和1两者循环变化\r\n            textNode.data = counter// 节点变化会触发回调handle，\r\n        }\r\n    } else {// 否则使用定时器\r\n        timerFunc = setTimeout\r\n    }\r\n    return function (cb, ctx) {\r\n        if (pending) return\r\n        pending = true\r\n        timerFunc(handle, 0)\r\n    }\r\n}\r\n\r\n\r\n/** \r\n * @Author: 王林 \r\n * @Date: 2021-06-26 22:40:52 \r\n * @Desc: 批量执行 \r\n */\r\nclass BatchExecution {\r\n    /** \r\n     * @Author: 王林 \r\n     * @Date: 2021-06-26 22:41:41 \r\n     * @Desc: 构造函数 \r\n     */\r\n    constructor() {\r\n        this.has = {}\r\n        this.queue = []\r\n        this.nextTick = nextTick(this.flush, this)\r\n    }\r\n\r\n    /** \r\n     * @Author: 王林 \r\n     * @Date: 2021-06-27 12:54:04 \r\n     * @Desc: 添加任务 \r\n     */\r\n    push(name, fn) {\r\n        if (this.has[name]) {\r\n            return;\r\n        }\r\n        this.has[name] = true\r\n        this.queue.push({\r\n            name,\r\n            fn\r\n        })\r\n        this.nextTick()\r\n    }\r\n\r\n    /** \r\n     * @Author: 王林 \r\n     * @Date: 2021-06-27 13:09:24 \r\n     * @Desc:  执行队列\r\n     */\r\n    flush() {\r\n        let fns = this.queue.slice(0)\r\n        this.queue = []\r\n        fns.forEach(({ name, fn }) => {\r\n            this.has[name] = false\r\n            fn()\r\n        })\r\n    }\r\n}\r\n\r\nexport default BatchExecution"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA,MAAMA,QAAQ,GAAG,UAAUC,EAAV,EAAcC,GAAd,EAAmB;EAChC,IAAIC,OAAO,GAAG,KAAd;EACA,IAAIC,SAAS,GAAG,IAAhB;;EACA,IAAIC,MAAM,GAAG,MAAM;IACfF,OAAO,GAAG,KAAV;IACAD,GAAG,GAAGD,EAAE,CAACK,IAAH,CAAQJ,GAAR,CAAH,GAAkBD,EAAE,EAAvB;EACH,CAHD,CAHgC,CAOhC;;;EACA,IAAI,OAAOM,gBAAP,KAA4B,WAAhC,EAA6C;IACzC,IAAIC,OAAO,GAAG,CAAd;IACA,IAAIC,QAAQ,GAAG,IAAIF,gBAAJ,CAAqBF,MAArB,CAAf;IACA,IAAIK,QAAQ,GAAGC,QAAQ,CAACC,cAAT,CAAwBJ,OAAxB,CAAf;IACAC,QAAQ,CAACI,OAAT,CAAiBH,QAAjB,EAA2B;MACvBI,aAAa,EAAE,IADQ,CACJ;;IADI,CAA3B;;IAGAV,SAAS,GAAG,YAAY;MACpBI,OAAO,GAAG,CAACA,OAAO,GAAG,CAAX,IAAgB,CAA1B,CADoB,CACO;;MAC3BE,QAAQ,CAACK,IAAT,GAAgBP,OAAhB,CAFoB,CAEG;IAC1B,CAHD;EAIH,CAXD,MAWO;IAAC;IACJJ,SAAS,GAAGY,UAAZ;EACH;;EACD,OAAO,UAAUC,EAAV,EAAcf,GAAd,EAAmB;IACtB,IAAIC,OAAJ,EAAa;IACbA,OAAO,GAAG,IAAV;IACAC,SAAS,CAACC,MAAD,EAAS,CAAT,CAAT;EACH,CAJD;AAKH,CA3BD;AA8BA;AACA;AACA;AACA;AACA;;;AACA,MAAMa,cAAN,CAAqB;EACjB;AACJ;AACA;AACA;AACA;EACIC,WAAW,GAAG;IACV,KAAKC,GAAL,GAAW,EAAX;IACA,KAAKC,KAAL,GAAa,EAAb;IACA,KAAKrB,QAAL,GAAgBA,QAAQ,CAAC,KAAKsB,KAAN,EAAa,IAAb,CAAxB;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIC,IAAI,CAACC,IAAD,EAAOvB,EAAP,EAAW;IACX,IAAI,KAAKmB,GAAL,CAASI,IAAT,CAAJ,EAAoB;MAChB;IACH;;IACD,KAAKJ,GAAL,CAASI,IAAT,IAAiB,IAAjB;IACA,KAAKH,KAAL,CAAWE,IAAX,CAAgB;MACZC,IADY;MAEZvB;IAFY,CAAhB;IAIA,KAAKD,QAAL;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIsB,KAAK,GAAG;IACJ,IAAIG,GAAG,GAAG,KAAKJ,KAAL,CAAWK,KAAX,CAAiB,CAAjB,CAAV;IACA,KAAKL,KAAL,GAAa,EAAb;IACAI,GAAG,CAACE,OAAJ,CAAY,CAAC;MAAEH,IAAF;MAAQvB;IAAR,CAAD,KAAkB;MAC1B,KAAKmB,GAAL,CAASI,IAAT,IAAiB,KAAjB;MACAvB,EAAE;IACL,CAHD;EAIH;;AAzCgB;;AA4CrB,eAAeiB,cAAf"},"metadata":{},"sourceType":"module"}