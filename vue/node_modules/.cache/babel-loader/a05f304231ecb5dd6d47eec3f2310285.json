{"ast":null,"code":"import Base from 'simple-mind-map/src/layouts/Base';\nimport { walk, asyncRun } from 'simple-mind-map/src/utils';\n/** \n * @Author: 王林 \n * @Date: 2021-04-12 22:25:58 \n * @Desc: 思维导图 \n * 在逻辑结构图的基础上增加一个变量来记录生长方向，向左还是向右，同时在计算left的时候根据方向来计算、调整top时只考虑同方向的节点即可\n */\n\nclass MindMap extends Base {\n  /** \n   * @Author: 王林 \n   * @Date: 2021-04-12 22:26:31 \n   * @Desc: 构造函数 \n   */\n  constructor(opt = {}) {\n    super(opt);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-06 14:04:20 \n   * @Desc: 布局\n   */\n\n\n  doLayout(callback) {\n    let task = [() => {\n      this.computedBaseValue();\n    }, () => {\n      this.computedTopValue();\n    }, () => {\n      this.adjustTopValue();\n    }, () => {\n      callback(this.root);\n    }];\n    asyncRun(task);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-08 09:49:32 \n   * @Desc: 遍历数据计算节点的left、width、height\n   */\n\n\n  computedBaseValue() {\n    walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex, index) => {\n      let newNode = this.createNode(cur, parent, isRoot, layerIndex); // 根节点定位在画布中心位置\n\n      if (isRoot) {\n        this.setNodeCenter(newNode);\n      } else {\n        // 非根节点\n        // 三级及以下节点以上级为准\n        if (parent._node.dir) {\n          newNode.dir = parent._node.dir;\n        } else {\n          // 节点生长方向\n          newNode.dir = index % 2 === 0 ? 'right' : 'left';\n        } // 根据生长方向定位到父节点的左侧或右侧\n\n\n        newNode.left = newNode.dir === 'right' ? parent._node.left + parent._node.width + this.getMarginX(layerIndex) : parent._node.left - this.getMarginX(layerIndex) - newNode.width;\n      }\n\n      if (!cur.data.expand) {\n        return true;\n      }\n    }, (cur, parent, isRoot, layerIndex) => {\n      // 返回时计算节点的leftChildrenAreaHeight和rightChildrenAreaHeight，也就是左侧和右侧子节点所占的高度之和，包括外边距\n      if (!cur.data.expand) {\n        cur._node.leftChildrenAreaHeight = 0;\n        cur._node.rightChildrenAreaHeight = 0;\n        return;\n      } // 理论上只有根节点是存在两个方向的子节点的，其他节点的子节点一定全都是同方向，但是为了逻辑统一，就不按特殊处理的方式来写了\n\n\n      let leftLen = 0;\n      let rightLen = 0;\n      let leftChildrenAreaHeight = 0;\n      let rightChildrenAreaHeight = 0;\n\n      cur._node.children.forEach(item => {\n        if (item.dir === 'left') {\n          leftLen++;\n          leftChildrenAreaHeight += item.height;\n        } else {\n          rightLen++;\n          rightChildrenAreaHeight += item.height;\n        }\n      });\n\n      cur._node.leftChildrenAreaHeight = leftChildrenAreaHeight + (leftLen + 1) * this.getMarginY(layerIndex + 1);\n      cur._node.rightChildrenAreaHeight = rightChildrenAreaHeight + (rightLen + 1) * this.getMarginY(layerIndex + 1);\n    }, true, 0);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-08 09:59:25 \n   * @Desc: 遍历节点树计算节点的top \n   */\n\n\n  computedTopValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (node.nodeData.data.expand && node.children && node.children.length) {\n        let marginY = this.getMarginY(layerIndex + 1);\n        let baseTop = node.top + node.height / 2 + marginY; // 第一个子节点的top值 = 该节点中心的top值 - 子节点的高度之和的一半\n\n        let leftTotalTop = baseTop - node.leftChildrenAreaHeight / 2;\n        let rightTotalTop = baseTop - node.rightChildrenAreaHeight / 2;\n        node.children.forEach(cur => {\n          if (cur.dir === 'left') {\n            cur.top = leftTotalTop;\n            leftTotalTop += cur.height + marginY;\n          } else {\n            cur.top = rightTotalTop;\n            rightTotalTop += cur.height + marginY;\n          }\n        });\n      }\n    }, null, true);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-08 10:04:05 \n   * @Desc: 调整节点top \n   */\n\n\n  adjustTopValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (!node.nodeData.data.expand) {\n        return;\n      } // 判断子节点所占的高度之和是否大于该节点自身，大于则需要调整位置\n\n\n      let base = this.getMarginY(layerIndex + 1) * 2 + node.height;\n      let leftDifference = node.leftChildrenAreaHeight - base;\n      let rightDifference = node.rightChildrenAreaHeight - base;\n\n      if (leftDifference > 0 || rightDifference > 0) {\n        this.updateBrothers(node, leftDifference / 2, rightDifference / 2);\n      }\n    }, null, true);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-07 14:26:03 \n   * @Desc: 更新兄弟节点的top\n   */\n\n\n  updateBrothers(node, leftAddHeight, rightAddHeight) {\n    if (node.parent) {\n      // 过滤出和自己同方向的节点\n      let childrenList = node.parent.children.filter(item => {\n        return item.dir === node.dir;\n      });\n      let index = childrenList.findIndex(item => {\n        return item === node;\n      });\n      childrenList.forEach((item, _index) => {\n        if (item.hasCustomPosition()) {\n          // 适配自定义位置\n          return;\n        }\n\n        let _offset = 0;\n        let addHeight = item.dir === 'left' ? leftAddHeight : rightAddHeight; // 上面的节点往上移\n\n        if (_index < index) {\n          _offset = -addHeight;\n        } else if (_index > index) {\n          // 下面的节点往下移\n          _offset = addHeight;\n        }\n\n        item.top += _offset; // 同步更新子节点的位置\n\n        if (item.children && item.children.length) {\n          this.updateChildren(item.children, 'top', _offset);\n        }\n      }); // 更新父节点的位置\n\n      this.updateBrothers(node.parent, leftAddHeight, rightAddHeight);\n    }\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2021-04-11 14:42:48 \n   * @Desc: 绘制连线，连接该节点到其子节点\n   */\n\n\n  renderLine(node, lines) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n\n    let {\n      left,\n      top,\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    node.children.forEach((item, index) => {\n      let x1 = node.layerIndex === 0 ? left + width / 2 : item.dir === 'left' ? left - expandBtnSize : left + width + 20;\n      let y1 = top + height / 2;\n      let x2 = item.dir === 'left' ? item.left + item.width : item.left;\n      let y2 = item.top + item.height / 2;\n      let path = '';\n\n      if (node.isRoot) {\n        path = this.quadraticCurvePath(x1, y1, x2, y2);\n      } else {\n        path = this.cubicBezierPath(x1, y1, x2, y2);\n      }\n\n      lines[index].plot(path);\n    });\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2021-04-11 19:54:26 \n   * @Desc: 渲染按钮 \n   */\n\n\n  renderExpandBtn(node, btn) {\n    let {\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    let {\n      translateX,\n      translateY\n    } = btn.transform();\n    let x = (node.dir === 'left' ? 0 - expandBtnSize : width) - translateX;\n    let y = height / 2 - translateY;\n    btn.translate(x, y);\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2022-07-30 08:30:35 \n   * @Desc: 创建概要节点 \n   */\n\n\n  renderGeneralization(node, gLine, gNode) {\n    let isLeft = node.dir === 'left';\n    let {\n      top,\n      bottom,\n      left,\n      right,\n      generalizationLineMargin,\n      generalizationNodeMargin\n    } = this.getNodeBoundaries(node, 'h', isLeft);\n    let x = isLeft ? left - generalizationLineMargin : right + generalizationLineMargin;\n    let x1 = x;\n    let y1 = top;\n    let x2 = x;\n    let y2 = bottom;\n    let cx = x1 + (isLeft ? -20 : 20);\n    let cy = y1 + (y2 - y1) / 2;\n    let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;\n    gLine.plot(path);\n    gNode.left = x + (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (isLeft ? gNode.width : 0);\n    gNode.top = top + (bottom - top - gNode.height) / 2;\n  }\n\n}\n\nexport default MindMap;","map":{"version":3,"names":["Base","walk","asyncRun","MindMap","constructor","opt","doLayout","callback","task","computedBaseValue","computedTopValue","adjustTopValue","root","renderer","renderTree","cur","parent","isRoot","layerIndex","index","newNode","createNode","setNodeCenter","_node","dir","left","width","getMarginX","data","expand","leftChildrenAreaHeight","rightChildrenAreaHeight","leftLen","rightLen","children","forEach","item","height","getMarginY","node","nodeData","length","marginY","baseTop","top","leftTotalTop","rightTotalTop","base","leftDifference","rightDifference","updateBrothers","leftAddHeight","rightAddHeight","childrenList","filter","findIndex","_index","hasCustomPosition","_offset","addHeight","updateChildren","renderLine","lines","expandBtnSize","x1","y1","x2","y2","path","quadraticCurvePath","cubicBezierPath","plot","renderExpandBtn","btn","translateX","translateY","transform","x","y","translate","renderGeneralization","gLine","gNode","isLeft","bottom","right","generalizationLineMargin","generalizationNodeMargin","getNodeBoundaries","cx","cy"],"sources":["D:/新建文件夹/git项目/GinTest/vue/node_modules/simple-mind-map/src/layouts/MindMap.js"],"sourcesContent":["import Base from 'simple-mind-map/src/layouts/Base';\nimport {\n    walk,\n    asyncRun\n} from 'simple-mind-map/src/utils'\n\n/** \n * @Author: 王林 \n * @Date: 2021-04-12 22:25:58 \n * @Desc: 思维导图 \n * 在逻辑结构图的基础上增加一个变量来记录生长方向，向左还是向右，同时在计算left的时候根据方向来计算、调整top时只考虑同方向的节点即可\n */\nclass MindMap extends Base {\n    /** \n     * @Author: 王林 \n     * @Date: 2021-04-12 22:26:31 \n     * @Desc: 构造函数 \n     */\n    constructor(opt = {}) {\n        super(opt)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-06 14:04:20 \n     * @Desc: 布局\n     */\n    doLayout(callback) {\n        let task = [() => {\n            this.computedBaseValue()\n        }, () => {\n            this.computedTopValue()\n        }, () => {\n            this.adjustTopValue()\n        }, () => {\n            callback(this.root)\n        }]\n        asyncRun(task)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-08 09:49:32 \n     * @Desc: 遍历数据计算节点的left、width、height\n     */\n    computedBaseValue() {\n        walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex, index) => {\n            let newNode = this.createNode(cur, parent, isRoot, layerIndex)\n            // 根节点定位在画布中心位置\n            if (isRoot) {\n                this.setNodeCenter(newNode)\n            } else {\n                // 非根节点\n                // 三级及以下节点以上级为准\n                if (parent._node.dir) {\n                    newNode.dir = parent._node.dir\n                } else { // 节点生长方向\n                    newNode.dir = index % 2 === 0 ? 'right' : 'left'\n                }\n                // 根据生长方向定位到父节点的左侧或右侧\n                newNode.left = newNode.dir === 'right' ? parent._node.left + parent._node.width + this.getMarginX(layerIndex) : parent._node.left - this.getMarginX(layerIndex) - newNode.width\n            }\n            if (!cur.data.expand) {\n                return true;\n            }\n        }, (cur, parent, isRoot, layerIndex) => {\n            // 返回时计算节点的leftChildrenAreaHeight和rightChildrenAreaHeight，也就是左侧和右侧子节点所占的高度之和，包括外边距\n            if (!cur.data.expand) {\n                cur._node.leftChildrenAreaHeight = 0\n                cur._node.rightChildrenAreaHeight = 0\n                return\n            }\n            // 理论上只有根节点是存在两个方向的子节点的，其他节点的子节点一定全都是同方向，但是为了逻辑统一，就不按特殊处理的方式来写了\n            let leftLen = 0\n            let rightLen = 0\n            let leftChildrenAreaHeight = 0\n            let rightChildrenAreaHeight = 0\n            cur._node.children.forEach((item) => {\n                if (item.dir === 'left') {\n                    leftLen++\n                    leftChildrenAreaHeight += item.height\n                } else {\n                    rightLen++\n                    rightChildrenAreaHeight += item.height\n                }\n            })\n            cur._node.leftChildrenAreaHeight = leftChildrenAreaHeight + (leftLen + 1) * this.getMarginY(layerIndex + 1)\n            cur._node.rightChildrenAreaHeight = rightChildrenAreaHeight + (rightLen + 1) * this.getMarginY(layerIndex + 1)\n        }, true, 0)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-08 09:59:25 \n     * @Desc: 遍历节点树计算节点的top \n     */\n    computedTopValue() {\n        walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n            if (node.nodeData.data.expand && node.children && node.children.length) {\n                let marginY = this.getMarginY(layerIndex + 1)\n                let baseTop = node.top + node.height / 2 + marginY\n                // 第一个子节点的top值 = 该节点中心的top值 - 子节点的高度之和的一半\n                let leftTotalTop = baseTop - node.leftChildrenAreaHeight / 2\n                let rightTotalTop = baseTop - node.rightChildrenAreaHeight / 2\n                node.children.forEach((cur) => {\n                    if (cur.dir === 'left') {\n                        cur.top = leftTotalTop\n                        leftTotalTop += cur.height + marginY\n                    } else {\n                        cur.top = rightTotalTop\n                        rightTotalTop += cur.height + marginY\n                    }\n                })\n            }\n        }, null, true)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-08 10:04:05 \n     * @Desc: 调整节点top \n     */\n    adjustTopValue() {\n        walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n            if (!node.nodeData.data.expand) {\n                return;\n            }\n            // 判断子节点所占的高度之和是否大于该节点自身，大于则需要调整位置\n            let base = this.getMarginY(layerIndex + 1) * 2 + node.height\n            let leftDifference = node.leftChildrenAreaHeight - base\n            let rightDifference = node.rightChildrenAreaHeight - base\n            if (leftDifference > 0 || rightDifference > 0) {\n                this.updateBrothers(node, leftDifference / 2, rightDifference / 2)\n            }\n        }, null, true)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-07 14:26:03 \n     * @Desc: 更新兄弟节点的top\n     */\n    updateBrothers(node, leftAddHeight, rightAddHeight) {\n        if (node.parent) {\n            // 过滤出和自己同方向的节点\n            let childrenList = node.parent.children.filter((item) => {\n                return item.dir === node.dir\n            })\n            let index = childrenList.findIndex((item) => {\n                return item === node\n            })\n            childrenList.forEach((item, _index) => {\n                if (item.hasCustomPosition()) {// 适配自定义位置\n                    return\n                }\n                let _offset = 0\n                let addHeight = item.dir === 'left' ? leftAddHeight : rightAddHeight\n                // 上面的节点往上移\n                if (_index < index) {\n                    _offset = -addHeight\n                } else if (_index > index) { // 下面的节点往下移\n                    _offset = addHeight\n                }\n                item.top += _offset\n                // 同步更新子节点的位置\n                if (item.children && item.children.length) {\n                    this.updateChildren(item.children, 'top', _offset)\n                }\n            })\n            // 更新父节点的位置\n            this.updateBrothers(node.parent, leftAddHeight, rightAddHeight)\n        }\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2021-04-11 14:42:48 \n     * @Desc: 绘制连线，连接该节点到其子节点\n     */\n    renderLine(node, lines) {\n        if (node.children.length <= 0) {\n            return [];\n        }\n        let {\n            left,\n            top,\n            width,\n            height,\n            expandBtnSize\n        } = node\n        node.children.forEach((item, index) => {\n            let x1 = node.layerIndex === 0 ? left + width / 2 : item.dir === 'left' ? left - expandBtnSize : left + width + 20\n            let y1 = top + height / 2\n            let x2 = item.dir === 'left' ? item.left + item.width : item.left\n            let y2 = item.top + item.height / 2\n            let path = ''\n            if (node.isRoot) {\n                path = this.quadraticCurvePath(x1, y1, x2, y2)\n            } else {\n                path = this.cubicBezierPath(x1, y1, x2, y2)\n            }\n            lines[index].plot(path)\n        })\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2021-04-11 19:54:26 \n     * @Desc: 渲染按钮 \n     */\n    renderExpandBtn(node, btn) {\n        let {\n            width,\n            height,\n            expandBtnSize\n        } = node\n        let {\n            translateX,\n            translateY\n        } = btn.transform()\n        let x = (node.dir === 'left' ? 0 - expandBtnSize : width) - translateX\n        let y = height / 2 - translateY\n        btn.translate(x, y)\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2022-07-30 08:30:35 \n     * @Desc: 创建概要节点 \n     */\n    renderGeneralization(node, gLine, gNode) {\n        let isLeft = node.dir === 'left'\n        let { top, bottom, left, right, generalizationLineMargin, generalizationNodeMargin } = this.getNodeBoundaries(node, 'h', isLeft)\n        let x = isLeft ? left - generalizationLineMargin : right + generalizationLineMargin\n        let x1 = x\n        let y1 = top\n        let x2 = x\n        let y2 = bottom\n        let cx = x1 + (isLeft ? -20 : 20)\n        let cy = y1 + (y2 - y1) / 2\n        let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`\n        gLine.plot(path)\n        gNode.left = x + (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (isLeft ? gNode.width : 0)\n        gNode.top = top + (bottom - top - gNode.height) / 2\n    }\n}\n\nexport default MindMap"],"mappings":"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"},"metadata":{},"sourceType":"module"}