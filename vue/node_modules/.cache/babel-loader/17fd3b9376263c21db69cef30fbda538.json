{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Base from 'simple-mind-map/src/layouts/Base';\nimport { walk, asyncRun } from 'simple-mind-map/src/utils';\n/** \n * @Author: 王林 \n * @Date: 2021-04-12 22:25:58 \n * @Desc: 组织结构图\n * 和逻辑结构图基本一样，只是方向变成向下生长，所以先计算节点的top，后计算节点的left、最后调整节点的left即可\n */\n\nclass OrganizationStructure extends Base {\n  /** \n   * @Author: 王林 \n   * @Date: 2021-04-12 22:26:31 \n   * @Desc: 构造函数 \n   */\n  constructor(opt = {}) {\n    super(opt);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-06 14:04:20 \n   * @Desc: 布局\n   */\n\n\n  doLayout(callback) {\n    let task = [() => {\n      this.computedBaseValue();\n    }, () => {\n      this.computedLeftValue();\n    }, () => {\n      this.adjustLeftValue();\n    }, () => {\n      callback(this.root);\n    }];\n    asyncRun(task);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-08 09:49:32 \n   * @Desc: 遍历数据计算节点的left、width、height\n   */\n\n\n  computedBaseValue() {\n    walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex) => {\n      let newNode = this.createNode(cur, parent, isRoot, layerIndex); // 根节点定位在画布中心位置\n\n      if (isRoot) {\n        this.setNodeCenter(newNode);\n      } else {\n        // 非根节点\n        // 定位到父节点下方\n        newNode.top = parent._node.top + parent._node.height + this.getMarginX(layerIndex);\n      }\n\n      if (!cur.data.expand) {\n        return true;\n      }\n    }, (cur, parent, isRoot, layerIndex) => {\n      // 返回时计算节点的areaWidth，也就是子节点所占的宽度之和，包括外边距\n      let len = cur.data.expand === false ? 0 : cur._node.children.length;\n      cur._node.childrenAreaWidth = len ? cur._node.children.reduce((h, item) => {\n        return h + item.width;\n      }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;\n    }, true, 0);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-08 09:59:25 \n   * @Desc: 遍历节点树计算节点的left\n   */\n\n\n  computedLeftValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (node.nodeData.data.expand && node.children && node.children.length) {\n        let marginX = this.getMarginY(layerIndex + 1); // 第一个子节点的left值 = 该节点中心的left值 - 子节点的宽度之和的一半\n\n        let left = node.left + node.width / 2 - node.childrenAreaWidth / 2;\n        let totalLeft = left + marginX;\n        node.children.forEach(cur => {\n          cur.left = totalLeft;\n          totalLeft += cur.width + marginX;\n        });\n      }\n    }, null, true);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-08 10:04:05 \n   * @Desc: 调整节点left\n   */\n\n\n  adjustLeftValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (!node.nodeData.data.expand) {\n        return;\n      } // 判断子节点所占的宽度之和是否大于该节点自身，大于则需要调整位置\n\n\n      let difference = node.childrenAreaWidth - this.getMarginY(layerIndex + 1) * 2 - node.width;\n\n      if (difference > 0) {\n        this.updateBrothers(node, difference / 2);\n      }\n    }, null, true);\n  }\n  /** \n   * javascript comment \n   * @Author: 王林25 \n   * @Date: 2021-04-07 14:26:03 \n   * @Desc: 更新兄弟节点的left\n   */\n\n\n  updateBrothers(node, addWidth) {\n    if (node.parent) {\n      let childrenList = node.parent.children;\n      let index = childrenList.findIndex(item => {\n        return item === node;\n      });\n      childrenList.forEach((item, _index) => {\n        if (item.hasCustomPosition()) {\n          // 适配自定义位置\n          return;\n        }\n\n        let _offset = 0; // 上面的节点往上移\n\n        if (_index < index) {\n          _offset = -addWidth;\n        } else if (_index > index) {\n          // 下面的节点往下移\n          _offset = addWidth;\n        }\n\n        item.left += _offset; // 同步更新子节点的位置\n\n        if (item.children && item.children.length) {\n          this.updateChildren(item.children, 'left', _offset);\n        }\n      }); // 更新父节点的位置\n\n      this.updateBrothers(node.parent, addWidth);\n    }\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2021-04-11 14:42:48 \n   * @Desc: 绘制连线，连接该节点到其子节点\n   */\n\n\n  renderLine(node, lines) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n\n    let {\n      left,\n      top,\n      width,\n      height,\n      expandBtnSize,\n      isRoot\n    } = node;\n    let x1 = left + width / 2;\n    let y1 = top + height;\n    let marginX = this.getMarginX(node.layerIndex + 1);\n    let s1 = marginX * 0.7;\n    let minx = Infinity;\n    let maxx = -Infinity;\n    let len = node.children.length;\n    node.children.forEach((item, index) => {\n      let x2 = item.left + item.width / 2;\n      let y2 = y1 + s1 > item.top ? item.top + item.height : item.top;\n\n      if (x2 < minx) {\n        minx = x2;\n      }\n\n      if (x2 > maxx) {\n        maxx = x2;\n      }\n\n      let path = `M ${x2},${y1 + s1} L ${x2},${y2}`;\n      lines[index].plot(path);\n    });\n    minx = Math.min(x1, minx);\n    maxx = Math.max(x1, maxx); // 父节点的竖线\n\n    let line1 = this.draw.path();\n    node.style.line(line1);\n    expandBtnSize = len > 0 && !isRoot ? expandBtnSize : 0;\n    line1.plot(`M ${x1},${y1 + expandBtnSize} L ${x1},${y1 + s1}`);\n\n    node._lines.push(line1); // 水平线\n\n\n    if (len > 0) {\n      let lin2 = this.draw.path();\n      node.style.line(lin2);\n      lin2.plot(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`);\n\n      node._lines.push(lin2);\n    }\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2021-04-11 19:54:26 \n   * @Desc: 渲染按钮 \n   */\n\n\n  renderExpandBtn(node, btn) {\n    let {\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    let {\n      translateX,\n      translateY\n    } = btn.transform();\n    btn.translate(width / 2 - expandBtnSize / 2 - translateX, height + expandBtnSize / 2 - translateY);\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2022-07-30 08:30:35 \n   * @Desc: 创建概要节点 \n   */\n\n\n  renderGeneralization(node, gLine, gNode) {\n    let {\n      bottom,\n      left,\n      right,\n      generalizationLineMargin,\n      generalizationNodeMargin\n    } = this.getNodeBoundaries(node, 'v');\n    let x1 = left;\n    let y1 = bottom + generalizationLineMargin;\n    let x2 = right;\n    let y2 = bottom + generalizationLineMargin;\n    let cx = x1 + (x2 - x1) / 2;\n    let cy = y1 + 20;\n    let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;\n    gLine.plot(path);\n    gNode.top = bottom + generalizationNodeMargin;\n    gNode.left = left + (right - left - gNode.width) / 2;\n  }\n\n}\n\nexport default OrganizationStructure;","map":{"version":3,"names":["Base","walk","asyncRun","OrganizationStructure","constructor","opt","doLayout","callback","task","computedBaseValue","computedLeftValue","adjustLeftValue","root","renderer","renderTree","cur","parent","isRoot","layerIndex","newNode","createNode","setNodeCenter","top","_node","height","getMarginX","data","expand","len","children","length","childrenAreaWidth","reduce","h","item","width","getMarginY","node","nodeData","marginX","left","totalLeft","forEach","difference","updateBrothers","addWidth","childrenList","index","findIndex","_index","hasCustomPosition","_offset","updateChildren","renderLine","lines","expandBtnSize","x1","y1","s1","minx","Infinity","maxx","x2","y2","path","plot","Math","min","max","line1","draw","style","line","_lines","push","lin2","renderExpandBtn","btn","translateX","translateY","transform","translate","renderGeneralization","gLine","gNode","bottom","right","generalizationLineMargin","generalizationNodeMargin","getNodeBoundaries","cx","cy"],"sources":["D:/新建文件夹/git项目/GinTest/vue/node_modules/simple-mind-map/src/layouts/OrganizationStructure.js"],"sourcesContent":["import Base from 'simple-mind-map/src/layouts/Base';\nimport {\n    walk,\n    asyncRun\n} from 'simple-mind-map/src/utils'\n\n/** \n * @Author: 王林 \n * @Date: 2021-04-12 22:25:58 \n * @Desc: 组织结构图\n * 和逻辑结构图基本一样，只是方向变成向下生长，所以先计算节点的top，后计算节点的left、最后调整节点的left即可\n */\nclass OrganizationStructure extends Base {\n    /** \n     * @Author: 王林 \n     * @Date: 2021-04-12 22:26:31 \n     * @Desc: 构造函数 \n     */\n    constructor(opt = {}) {\n        super(opt)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-06 14:04:20 \n     * @Desc: 布局\n     */\n    doLayout(callback) {\n        let task = [() => {\n            this.computedBaseValue()\n        }, () => {\n            this.computedLeftValue()\n        }, () => {\n            this.adjustLeftValue()\n        }, () => {\n            callback(this.root)\n        }]\n        asyncRun(task)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-08 09:49:32 \n     * @Desc: 遍历数据计算节点的left、width、height\n     */\n    computedBaseValue() {\n        walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex) => {\n            let newNode = this.createNode(cur, parent, isRoot, layerIndex)\n            // 根节点定位在画布中心位置\n            if (isRoot) {\n                this.setNodeCenter(newNode)\n            } else {\n                // 非根节点\n                // 定位到父节点下方\n                newNode.top = parent._node.top + parent._node.height + this.getMarginX(layerIndex)\n            }\n            if (!cur.data.expand) {\n                return true;\n            }\n        }, (cur, parent, isRoot, layerIndex) => {\n            // 返回时计算节点的areaWidth，也就是子节点所占的宽度之和，包括外边距\n            let len = cur.data.expand === false ? 0 : cur._node.children.length\n            cur._node.childrenAreaWidth = len ? cur._node.children.reduce((h, item) => {\n                return h + item.width\n            }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0\n        }, true, 0)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-08 09:59:25 \n     * @Desc: 遍历节点树计算节点的left\n     */\n    computedLeftValue() {\n        walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n            if (node.nodeData.data.expand && node.children && node.children.length) {\n                let marginX = this.getMarginY(layerIndex + 1)\n                // 第一个子节点的left值 = 该节点中心的left值 - 子节点的宽度之和的一半\n                let left = node.left + node.width / 2 - node.childrenAreaWidth / 2\n                let totalLeft = left + marginX\n                node.children.forEach((cur) => {\n                    cur.left = totalLeft\n                    totalLeft += cur.width + marginX\n                })\n            }\n        }, null, true)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-08 10:04:05 \n     * @Desc: 调整节点left\n     */\n    adjustLeftValue() {\n        walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n            if (!node.nodeData.data.expand) {\n                return;\n            }\n            // 判断子节点所占的宽度之和是否大于该节点自身，大于则需要调整位置\n            let difference = node.childrenAreaWidth - this.getMarginY(layerIndex + 1) * 2 - node.width\n            if (difference > 0) {\n                this.updateBrothers(node, difference / 2)\n            }\n        }, null, true)\n    }\n\n    /** \n     * javascript comment \n     * @Author: 王林25 \n     * @Date: 2021-04-07 14:26:03 \n     * @Desc: 更新兄弟节点的left\n     */\n    updateBrothers(node, addWidth) {\n        if (node.parent) {\n            let childrenList = node.parent.children\n            let index = childrenList.findIndex((item) => {\n                return item === node\n            })\n            childrenList.forEach((item, _index) => {\n                if (item.hasCustomPosition()) {// 适配自定义位置\n                    return\n                }\n                let _offset = 0\n                // 上面的节点往上移\n                if (_index < index) {\n                    _offset = -addWidth\n                } else if (_index > index) { // 下面的节点往下移\n                    _offset = addWidth\n                }\n                item.left += _offset\n                // 同步更新子节点的位置\n                if (item.children && item.children.length) {\n                    this.updateChildren(item.children, 'left', _offset)\n                }\n            })\n            // 更新父节点的位置\n            this.updateBrothers(node.parent, addWidth)\n        }\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2021-04-11 14:42:48 \n     * @Desc: 绘制连线，连接该节点到其子节点\n     */\n    renderLine(node, lines) {\n        if (node.children.length <= 0) {\n            return [];\n        }\n        let {\n            left,\n            top,\n            width,\n            height,\n            expandBtnSize,\n            isRoot\n        } = node\n        let x1 = left + width / 2\n        let y1 = top + height\n        let marginX = this.getMarginX(node.layerIndex + 1)\n        let s1 = marginX * 0.7\n        let minx = Infinity\n        let maxx = -Infinity\n        let len = node.children.length\n        node.children.forEach((item, index) => {\n            let x2 = item.left + item.width / 2\n            let y2 = y1 + s1 > item.top ? item.top + item.height : item.top\n            if (x2 < minx) {\n                minx = x2\n            }\n            if (x2 > maxx) {\n                maxx = x2\n            }\n            let path = `M ${x2},${y1 + s1} L ${x2},${y2}`\n            lines[index].plot(path)\n        })\n        minx = Math.min(x1, minx)\n        maxx = Math.max(x1, maxx)\n        // 父节点的竖线\n        let line1 = this.draw.path()\n        node.style.line(line1)\n        expandBtnSize = len > 0 && !isRoot ? expandBtnSize : 0\n        line1.plot(`M ${x1},${y1 + expandBtnSize} L ${x1},${y1 + s1}`)\n        node._lines.push(line1)\n        // 水平线\n        if (len > 0) {\n            let lin2 = this.draw.path()\n            node.style.line(lin2)\n            lin2.plot(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`)\n            node._lines.push(lin2)\n        }\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2021-04-11 19:54:26 \n     * @Desc: 渲染按钮 \n     */\n    renderExpandBtn(node, btn) {\n        let {\n            width,\n            height,\n            expandBtnSize\n        } = node\n        let {\n            translateX,\n            translateY\n        } = btn.transform()\n        btn.translate(width / 2 - expandBtnSize / 2 - translateX, height + expandBtnSize / 2 - translateY)\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2022-07-30 08:30:35 \n     * @Desc: 创建概要节点 \n     */\n    renderGeneralization(node, gLine, gNode) {\n        let { bottom, left, right, generalizationLineMargin, generalizationNodeMargin } = this.getNodeBoundaries(node, 'v')\n        let x1 = left\n        let y1 = bottom + generalizationLineMargin\n        let x2 = right\n        let y2 = bottom + generalizationLineMargin\n        let cx = x1 + (x2 - x1) / 2\n        let cy = y1 + 20\n        let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`\n        gLine.plot(path)\n        gNode.top = bottom + generalizationNodeMargin\n        gNode.left = left + (right - left - gNode.width) / 2\n    }\n}\n\nexport default OrganizationStructure"],"mappings":"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"},"metadata":{},"sourceType":"module"}