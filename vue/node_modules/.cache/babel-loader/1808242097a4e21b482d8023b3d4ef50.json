{"ast":null,"code":"/** \n * @Author: 王林 \n * @Date: 2021-06-27 13:16:23 \n * @Desc: 在下一个事件循环里执行任务 \n */\nconst nextTick = function (fn, ctx) {\n  let pending = false;\n  let timerFunc = null;\n\n  let handle = () => {\n    pending = false;\n    ctx ? fn.call(ctx) : fn();\n  }; // 支持MutationObserver接口的话使用MutationObserver\n\n\n  if (typeof MutationObserver !== 'undefined') {\n    let counter = 1;\n    let observer = new MutationObserver(handle);\n    let textNode = document.createTextNode(counter);\n    observer.observe(textNode, {\n      characterData: true // 设为 true 表示监视指定目标节点或子节点树中节点所包含的字符数据的变化\n\n    });\n\n    timerFunc = function () {\n      counter = (counter + 1) % 2; // counter会在0和1两者循环变化\n\n      textNode.data = counter; // 节点变化会触发回调handle，\n    };\n  } else {\n    // 否则使用定时器\n    timerFunc = setTimeout;\n  }\n\n  return function (cb, ctx) {\n    if (pending) return;\n    pending = true;\n    timerFunc(handle, 0);\n  };\n};\n/** \n * @Author: 王林 \n * @Date: 2021-06-26 22:40:52 \n * @Desc: 批量执行 \n */\n\n\nclass BatchExecution {\n  /** \n   * @Author: 王林 \n   * @Date: 2021-06-26 22:41:41 \n   * @Desc: 构造函数 \n   */\n  constructor() {\n    this.has = {};\n    this.queue = [];\n    this.nextTick = nextTick(this.flush, this);\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2021-06-27 12:54:04 \n   * @Desc: 添加任务 \n   */\n\n\n  push(name, fn) {\n    if (this.has[name]) {\n      return;\n    }\n\n    this.has[name] = true;\n    this.queue.push({\n      name,\n      fn\n    });\n    this.nextTick();\n  }\n  /** \n   * @Author: 王林 \n   * @Date: 2021-06-27 13:09:24 \n   * @Desc:  执行队列\n   */\n\n\n  flush() {\n    let fns = this.queue.slice(0);\n    this.queue = [];\n    fns.forEach(({\n      name,\n      fn\n    }) => {\n      this.has[name] = false;\n      fn();\n    });\n  }\n\n}\n\nexport default BatchExecution;","map":{"version":3,"names":["nextTick","fn","ctx","pending","timerFunc","handle","call","MutationObserver","counter","observer","textNode","document","createTextNode","observe","characterData","data","setTimeout","cb","BatchExecution","constructor","has","queue","flush","push","name","fns","slice","forEach"],"sources":["C:/Users/13007/Documents/GinTest/vue/node_modules/simple-mind-map/src/BatchExecution.js"],"sourcesContent":["/** \n * @Author: 王林 \n * @Date: 2021-06-27 13:16:23 \n * @Desc: 在下一个事件循环里执行任务 \n */\nconst nextTick = function (fn, ctx) {\n    let pending = false\n    let timerFunc = null\n    let handle = () => {\n        pending = false\n        ctx ? fn.call(ctx) : fn()\n    }\n    // 支持MutationObserver接口的话使用MutationObserver\n    if (typeof MutationObserver !== 'undefined') {\n        let counter = 1\n        let observer = new MutationObserver(handle)\n        let textNode = document.createTextNode(counter)\n        observer.observe(textNode, {\n            characterData: true// 设为 true 表示监视指定目标节点或子节点树中节点所包含的字符数据的变化\n        })\n        timerFunc = function () {\n            counter = (counter + 1) % 2// counter会在0和1两者循环变化\n            textNode.data = counter// 节点变化会触发回调handle，\n        }\n    } else {// 否则使用定时器\n        timerFunc = setTimeout\n    }\n    return function (cb, ctx) {\n        if (pending) return\n        pending = true\n        timerFunc(handle, 0)\n    }\n}\n\n\n/** \n * @Author: 王林 \n * @Date: 2021-06-26 22:40:52 \n * @Desc: 批量执行 \n */\nclass BatchExecution {\n    /** \n     * @Author: 王林 \n     * @Date: 2021-06-26 22:41:41 \n     * @Desc: 构造函数 \n     */\n    constructor() {\n        this.has = {}\n        this.queue = []\n        this.nextTick = nextTick(this.flush, this)\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2021-06-27 12:54:04 \n     * @Desc: 添加任务 \n     */\n    push(name, fn) {\n        if (this.has[name]) {\n            return;\n        }\n        this.has[name] = true\n        this.queue.push({\n            name,\n            fn\n        })\n        this.nextTick()\n    }\n\n    /** \n     * @Author: 王林 \n     * @Date: 2021-06-27 13:09:24 \n     * @Desc:  执行队列\n     */\n    flush() {\n        let fns = this.queue.slice(0)\n        this.queue = []\n        fns.forEach(({ name, fn }) => {\n            this.has[name] = false\n            fn()\n        })\n    }\n}\n\nexport default BatchExecution"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,MAAMA,QAAQ,GAAG,UAAUC,EAAV,EAAcC,GAAd,EAAmB;EAChC,IAAIC,OAAO,GAAG,KAAd;EACA,IAAIC,SAAS,GAAG,IAAhB;;EACA,IAAIC,MAAM,GAAG,MAAM;IACfF,OAAO,GAAG,KAAV;IACAD,GAAG,GAAGD,EAAE,CAACK,IAAH,CAAQJ,GAAR,CAAH,GAAkBD,EAAE,EAAvB;EACH,CAHD,CAHgC,CAOhC;;;EACA,IAAI,OAAOM,gBAAP,KAA4B,WAAhC,EAA6C;IACzC,IAAIC,OAAO,GAAG,CAAd;IACA,IAAIC,QAAQ,GAAG,IAAIF,gBAAJ,CAAqBF,MAArB,CAAf;IACA,IAAIK,QAAQ,GAAGC,QAAQ,CAACC,cAAT,CAAwBJ,OAAxB,CAAf;IACAC,QAAQ,CAACI,OAAT,CAAiBH,QAAjB,EAA2B;MACvBI,aAAa,EAAE,IADQ,CACJ;;IADI,CAA3B;;IAGAV,SAAS,GAAG,YAAY;MACpBI,OAAO,GAAG,CAACA,OAAO,GAAG,CAAX,IAAgB,CAA1B,CADoB,CACO;;MAC3BE,QAAQ,CAACK,IAAT,GAAgBP,OAAhB,CAFoB,CAEG;IAC1B,CAHD;EAIH,CAXD,MAWO;IAAC;IACJJ,SAAS,GAAGY,UAAZ;EACH;;EACD,OAAO,UAAUC,EAAV,EAAcf,GAAd,EAAmB;IACtB,IAAIC,OAAJ,EAAa;IACbA,OAAO,GAAG,IAAV;IACAC,SAAS,CAACC,MAAD,EAAS,CAAT,CAAT;EACH,CAJD;AAKH,CA3BD;AA8BA;AACA;AACA;AACA;AACA;;;AACA,MAAMa,cAAN,CAAqB;EACjB;AACJ;AACA;AACA;AACA;EACIC,WAAW,GAAG;IACV,KAAKC,GAAL,GAAW,EAAX;IACA,KAAKC,KAAL,GAAa,EAAb;IACA,KAAKrB,QAAL,GAAgBA,QAAQ,CAAC,KAAKsB,KAAN,EAAa,IAAb,CAAxB;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIC,IAAI,CAACC,IAAD,EAAOvB,EAAP,EAAW;IACX,IAAI,KAAKmB,GAAL,CAASI,IAAT,CAAJ,EAAoB;MAChB;IACH;;IACD,KAAKJ,GAAL,CAASI,IAAT,IAAiB,IAAjB;IACA,KAAKH,KAAL,CAAWE,IAAX,CAAgB;MACZC,IADY;MAEZvB;IAFY,CAAhB;IAIA,KAAKD,QAAL;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIsB,KAAK,GAAG;IACJ,IAAIG,GAAG,GAAG,KAAKJ,KAAL,CAAWK,KAAX,CAAiB,CAAjB,CAAV;IACA,KAAKL,KAAL,GAAa,EAAb;IACAI,GAAG,CAACE,OAAJ,CAAY,CAAC;MAAEH,IAAF;MAAQvB;IAAR,CAAD,KAAkB;MAC1B,KAAKmB,GAAL,CAASI,IAAT,IAAiB,KAAjB;MACAvB,EAAE;IACL,CAHD;EAIH;;AAzCgB;;AA4CrB,eAAeiB,cAAf"},"metadata":{},"sourceType":"module"}