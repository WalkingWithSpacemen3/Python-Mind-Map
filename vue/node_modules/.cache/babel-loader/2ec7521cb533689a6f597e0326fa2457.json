{"ast":null,"code":"import Base from 'simple-mind-map/src/layouts/Base';\nimport { walk, asyncRun } from 'simple-mind-map/src/utils';\n/** \r\n * @Author: 王林 \r\n * @Date: 2021-04-12 22:25:58 \r\n * @Desc: 逻辑结构图 \r\n */\n\nclass LogicalStructure extends Base {\n  /** \r\n   * @Author: 王林 \r\n   * @Date: 2021-04-12 22:26:31 \r\n   * @Desc: 构造函数 \r\n   */\n  constructor(opt = {}) {\n    super(opt);\n  }\n  /** \r\n   * javascript comment \r\n   * @Author: 王林25 \r\n   * @Date: 2021-04-06 14:04:20 \r\n   * @Desc: 布局\r\n   */\n\n\n  doLayout(callback) {\n    let task = [() => {\n      this.computedBaseValue();\n    }, () => {\n      this.computedTopValue();\n    }, () => {\n      this.adjustTopValue();\n    }, () => {\n      callback(this.root);\n    }];\n    asyncRun(task);\n  }\n  /** \r\n   * javascript comment \r\n   * @Author: 王林25 \r\n   * @Date: 2021-04-08 09:49:32 \r\n   * @Desc: 遍历数据计算节点的left、width、height\r\n   */\n\n\n  computedBaseValue() {\n    walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex) => {\n      let newNode = this.createNode(cur, parent, isRoot, layerIndex); // 根节点定位在画布中心位置\n\n      if (isRoot) {\n        this.setNodeCenter(newNode);\n      } else {\n        // 非根节点\n        // 定位到父节点右侧\n        newNode.left = parent._node.left + parent._node.width + this.getMarginX(layerIndex);\n      }\n\n      if (!cur.data.expand) {\n        return true;\n      }\n    }, (cur, parent, isRoot, layerIndex) => {\n      // 返回时计算节点的areaHeight，也就是子节点所占的高度之和，包括外边距\n      let len = cur.data.expand === false ? 0 : cur._node.children.length;\n      cur._node.childrenAreaHeight = len ? cur._node.children.reduce((h, item) => {\n        return h + item.height;\n      }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;\n    }, true, 0);\n  }\n  /** \r\n   * javascript comment \r\n   * @Author: 王林25 \r\n   * @Date: 2021-04-08 09:59:25 \r\n   * @Desc: 遍历节点树计算节点的top \r\n   */\n\n\n  computedTopValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (node.nodeData.data.expand && node.children && node.children.length) {\n        let marginY = this.getMarginY(layerIndex + 1); // 第一个子节点的top值 = 该节点中心的top值 - 子节点的高度之和的一半\n\n        let top = node.top + node.height / 2 - node.childrenAreaHeight / 2;\n        let totalTop = top + marginY;\n        node.children.forEach(cur => {\n          cur.top = totalTop;\n          totalTop += cur.height + marginY;\n        });\n      }\n    }, null, true);\n  }\n  /** \r\n   * javascript comment \r\n   * @Author: 王林25 \r\n   * @Date: 2021-04-08 10:04:05 \r\n   * @Desc: 调整节点top \r\n   */\n\n\n  adjustTopValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (!node.nodeData.data.expand) {\n        return;\n      } // 判断子节点所占的高度之和是否大于该节点自身，大于则需要调整位置\n\n\n      let difference = node.childrenAreaHeight - this.getMarginY(layerIndex + 1) * 2 - node.height;\n\n      if (difference > 0) {\n        this.updateBrothers(node, difference / 2);\n      }\n    }, null, true);\n  }\n  /** \r\n   * javascript comment \r\n   * @Author: 王林25 \r\n   * @Date: 2021-04-07 14:26:03 \r\n   * @Desc: 更新兄弟节点的top\r\n   */\n\n\n  updateBrothers(node, addHeight) {\n    if (node.parent) {\n      let childrenList = node.parent.children;\n      let index = childrenList.findIndex(item => {\n        return item === node;\n      });\n      childrenList.forEach((item, _index) => {\n        if (item === node || item.hasCustomPosition()) {\n          // 适配自定义位置\n          return;\n        }\n\n        let _offset = 0; // 上面的节点往上移\n\n        if (_index < index) {\n          _offset = -addHeight;\n        } else if (_index > index) {\n          // 下面的节点往下移\n          _offset = addHeight;\n        }\n\n        item.top += _offset; // 同步更新子节点的位置\n\n        if (item.children && item.children.length) {\n          this.updateChildren(item.children, 'top', _offset);\n        }\n      }); // 更新父节点的位置\n\n      this.updateBrothers(node.parent, addHeight);\n    }\n  }\n  /** \r\n   * @Author: 王林 \r\n   * @Date: 2021-04-11 14:42:48 \r\n   * @Desc: 绘制连线，连接该节点到其子节点\r\n   */\n\n\n  renderLine(node, lines) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n\n    let {\n      left,\n      top,\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    node.children.forEach((item, index) => {\n      let x1 = node.layerIndex === 0 ? left + width / 2 : left + width + expandBtnSize;\n      let y1 = top + height / 2;\n      let x2 = item.left;\n      let y2 = item.top + item.height / 2;\n      let path = '';\n\n      if (node.isRoot) {\n        path = this.quadraticCurvePath(x1, y1, x2, y2);\n      } else {\n        path = this.cubicBezierPath(x1, y1, x2, y2);\n      }\n\n      lines[index].plot(path);\n    });\n  }\n  /** \r\n   * @Author: 王林 \r\n   * @Date: 2021-04-11 19:54:26 \r\n   * @Desc: 渲染按钮 \r\n   */\n\n\n  renderExpandBtn(node, btn) {\n    let {\n      width,\n      height\n    } = node;\n    let {\n      translateX,\n      translateY\n    } = btn.transform();\n    btn.translate(width - translateX, height / 2 - translateY);\n  }\n  /** \r\n   * @Author: 王林 \r\n   * @Date: 2022-07-30 08:30:35 \r\n   * @Desc: 创建概要节点 \r\n   */\n\n\n  renderGeneralization(node, gLine, gNode) {\n    let {\n      top,\n      bottom,\n      right,\n      generalizationLineMargin,\n      generalizationNodeMargin\n    } = this.getNodeBoundaries(node, 'h');\n    let x1 = right + generalizationLineMargin;\n    let y1 = top;\n    let x2 = right + generalizationLineMargin;\n    let y2 = bottom;\n    let cx = x1 + 20;\n    let cy = y1 + (y2 - y1) / 2;\n    let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;\n    gLine.plot(path);\n    gNode.left = right + generalizationNodeMargin;\n    gNode.top = top + (bottom - top - gNode.height) / 2;\n  }\n\n}\n\nexport default LogicalStructure;","map":{"version":3,"names":["Base","walk","asyncRun","LogicalStructure","constructor","opt","doLayout","callback","task","computedBaseValue","computedTopValue","adjustTopValue","root","renderer","renderTree","cur","parent","isRoot","layerIndex","newNode","createNode","setNodeCenter","left","_node","width","getMarginX","data","expand","len","children","length","childrenAreaHeight","reduce","h","item","height","getMarginY","node","nodeData","marginY","top","totalTop","forEach","difference","updateBrothers","addHeight","childrenList","index","findIndex","_index","hasCustomPosition","_offset","updateChildren","renderLine","lines","expandBtnSize","x1","y1","x2","y2","path","quadraticCurvePath","cubicBezierPath","plot","renderExpandBtn","btn","translateX","translateY","transform","translate","renderGeneralization","gLine","gNode","bottom","right","generalizationLineMargin","generalizationNodeMargin","getNodeBoundaries","cx","cy"],"sources":["C:/Users/13007/Documents/GinTest/vue/node_modules/simple-mind-map/src/layouts/LogicalStructure.js"],"sourcesContent":["import Base from 'simple-mind-map/src/layouts/Base';\r\nimport {\r\n    walk,\r\n    asyncRun\r\n} from 'simple-mind-map/src/utils'\r\n\r\n/** \r\n * @Author: 王林 \r\n * @Date: 2021-04-12 22:25:58 \r\n * @Desc: 逻辑结构图 \r\n */\r\nclass LogicalStructure extends Base {\r\n    /** \r\n     * @Author: 王林 \r\n     * @Date: 2021-04-12 22:26:31 \r\n     * @Desc: 构造函数 \r\n     */\r\n    constructor(opt = {}) {\r\n        super(opt)\r\n    }\r\n\r\n    /** \r\n     * javascript comment \r\n     * @Author: 王林25 \r\n     * @Date: 2021-04-06 14:04:20 \r\n     * @Desc: 布局\r\n     */\r\n    doLayout(callback) {\r\n        let task = [() => {\r\n            this.computedBaseValue()\r\n        }, () => {\r\n            this.computedTopValue()\r\n        }, () => {\r\n            this.adjustTopValue()\r\n        }, () => {\r\n            callback(this.root)\r\n        }]\r\n        asyncRun(task)\r\n    }\r\n\r\n    /** \r\n     * javascript comment \r\n     * @Author: 王林25 \r\n     * @Date: 2021-04-08 09:49:32 \r\n     * @Desc: 遍历数据计算节点的left、width、height\r\n     */\r\n    computedBaseValue() {\r\n        walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex) => {\r\n            let newNode = this.createNode(cur, parent, isRoot, layerIndex)\r\n            // 根节点定位在画布中心位置\r\n            if (isRoot) {\r\n                this.setNodeCenter(newNode)\r\n            } else {\r\n                // 非根节点\r\n                // 定位到父节点右侧\r\n                newNode.left = parent._node.left + parent._node.width + this.getMarginX(layerIndex)\r\n            }\r\n            if (!cur.data.expand) {\r\n                return true;\r\n            }\r\n        }, (cur, parent, isRoot, layerIndex) => {\r\n            // 返回时计算节点的areaHeight，也就是子节点所占的高度之和，包括外边距\r\n            let len = cur.data.expand === false ? 0 : cur._node.children.length\r\n            cur._node.childrenAreaHeight = len ? cur._node.children.reduce((h, item) => {\r\n                return h + item.height\r\n            }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0\r\n        }, true, 0)\r\n    }\r\n\r\n    /** \r\n     * javascript comment \r\n     * @Author: 王林25 \r\n     * @Date: 2021-04-08 09:59:25 \r\n     * @Desc: 遍历节点树计算节点的top \r\n     */\r\n    computedTopValue() {\r\n        walk(this.root, null, (node, parent, isRoot, layerIndex) => {\r\n            if (node.nodeData.data.expand && node.children && node.children.length) {\r\n                let marginY = this.getMarginY(layerIndex + 1)\r\n                // 第一个子节点的top值 = 该节点中心的top值 - 子节点的高度之和的一半\r\n                let top = node.top + node.height / 2 - node.childrenAreaHeight / 2\r\n                let totalTop = top + marginY\r\n                node.children.forEach((cur) => {\r\n                    cur.top = totalTop\r\n                    totalTop += cur.height + marginY\r\n                })\r\n            }\r\n        }, null, true)\r\n    }\r\n\r\n    /** \r\n     * javascript comment \r\n     * @Author: 王林25 \r\n     * @Date: 2021-04-08 10:04:05 \r\n     * @Desc: 调整节点top \r\n     */\r\n    adjustTopValue() {\r\n        walk(this.root, null, (node, parent, isRoot, layerIndex) => {\r\n            if (!node.nodeData.data.expand) {\r\n                return;\r\n            }\r\n            // 判断子节点所占的高度之和是否大于该节点自身，大于则需要调整位置\r\n            let difference = node.childrenAreaHeight - this.getMarginY(layerIndex + 1) * 2 - node.height\r\n            if (difference > 0) {\r\n                this.updateBrothers(node, difference / 2)\r\n            }\r\n        }, null, true)\r\n    }\r\n\r\n    /** \r\n     * javascript comment \r\n     * @Author: 王林25 \r\n     * @Date: 2021-04-07 14:26:03 \r\n     * @Desc: 更新兄弟节点的top\r\n     */\r\n    updateBrothers(node, addHeight) {\r\n        if (node.parent) {\r\n            let childrenList = node.parent.children\r\n            let index = childrenList.findIndex((item) => {\r\n                return item === node\r\n            })\r\n            childrenList.forEach((item, _index) => {\r\n                if (item === node || item.hasCustomPosition()) {// 适配自定义位置\r\n                    return\r\n                }\r\n                let _offset = 0\r\n                // 上面的节点往上移\r\n                if (_index < index) {\r\n                    _offset = -addHeight\r\n                } else if (_index > index) { // 下面的节点往下移\r\n                    _offset = addHeight\r\n                }\r\n                item.top += _offset\r\n                // 同步更新子节点的位置\r\n                if (item.children && item.children.length) {\r\n                    this.updateChildren(item.children, 'top', _offset)\r\n                }\r\n            })\r\n            // 更新父节点的位置\r\n            this.updateBrothers(node.parent, addHeight)\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @Author: 王林 \r\n     * @Date: 2021-04-11 14:42:48 \r\n     * @Desc: 绘制连线，连接该节点到其子节点\r\n     */\r\n    renderLine(node, lines) {\r\n        if (node.children.length <= 0) {\r\n            return [];\r\n        }\r\n        let {\r\n            left,\r\n            top,\r\n            width,\r\n            height,\r\n            expandBtnSize\r\n        } = node\r\n        node.children.forEach((item, index) => {\r\n            let x1 = node.layerIndex === 0 ? left + width / 2 : left + width + expandBtnSize\r\n            let y1 = top + height / 2\r\n            let x2 = item.left\r\n            let y2 = item.top + item.height / 2\r\n            let path = ''\r\n            if (node.isRoot) {\r\n                path = this.quadraticCurvePath(x1, y1, x2, y2)\r\n            } else {\r\n                path = this.cubicBezierPath(x1, y1, x2, y2)\r\n            }\r\n            lines[index].plot(path)\r\n        })\r\n    }\r\n\r\n    /** \r\n     * @Author: 王林 \r\n     * @Date: 2021-04-11 19:54:26 \r\n     * @Desc: 渲染按钮 \r\n     */\r\n    renderExpandBtn(node, btn) {\r\n        let {\r\n            width,\r\n            height\r\n        } = node\r\n        let {\r\n            translateX,\r\n            translateY\r\n        } = btn.transform()\r\n        btn.translate(width - translateX, height / 2 - translateY)\r\n    }\r\n\r\n    /** \r\n     * @Author: 王林 \r\n     * @Date: 2022-07-30 08:30:35 \r\n     * @Desc: 创建概要节点 \r\n     */\r\n    renderGeneralization(node, gLine, gNode) {\r\n        let { top, bottom, right, generalizationLineMargin, generalizationNodeMargin } = this.getNodeBoundaries(node, 'h')\r\n        let x1 = right + generalizationLineMargin\r\n        let y1 = top\r\n        let x2 = right + generalizationLineMargin\r\n        let y2 = bottom\r\n        let cx = x1 + 20\r\n        let cy = y1 + (y2 - y1) / 2\r\n        let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`\r\n        gLine.plot(path)\r\n        gNode.left = right + generalizationNodeMargin\r\n        gNode.top = top + (bottom - top - gNode.height) / 2\r\n    }\r\n}\r\n\r\nexport default LogicalStructure"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,kCAAjB;AACA,SACIC,IADJ,EAEIC,QAFJ,QAGO,2BAHP;AAKA;AACA;AACA;AACA;AACA;;AACA,MAAMC,gBAAN,SAA+BH,IAA/B,CAAoC;EAChC;AACJ;AACA;AACA;AACA;EACII,WAAW,CAACC,GAAG,GAAG,EAAP,EAAW;IAClB,MAAMA,GAAN;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIC,QAAQ,CAACC,QAAD,EAAW;IACf,IAAIC,IAAI,GAAG,CAAC,MAAM;MACd,KAAKC,iBAAL;IACH,CAFU,EAER,MAAM;MACL,KAAKC,gBAAL;IACH,CAJU,EAIR,MAAM;MACL,KAAKC,cAAL;IACH,CANU,EAMR,MAAM;MACLJ,QAAQ,CAAC,KAAKK,IAAN,CAAR;IACH,CARU,CAAX;IASAV,QAAQ,CAACM,IAAD,CAAR;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIC,iBAAiB,GAAG;IAChBR,IAAI,CAAC,KAAKY,QAAL,CAAcC,UAAf,EAA2B,IAA3B,EAAiC,CAACC,GAAD,EAAMC,MAAN,EAAcC,MAAd,EAAsBC,UAAtB,KAAqC;MACtE,IAAIC,OAAO,GAAG,KAAKC,UAAL,CAAgBL,GAAhB,EAAqBC,MAArB,EAA6BC,MAA7B,EAAqCC,UAArC,CAAd,CADsE,CAEtE;;MACA,IAAID,MAAJ,EAAY;QACR,KAAKI,aAAL,CAAmBF,OAAnB;MACH,CAFD,MAEO;QACH;QACA;QACAA,OAAO,CAACG,IAAR,GAAeN,MAAM,CAACO,KAAP,CAAaD,IAAb,GAAoBN,MAAM,CAACO,KAAP,CAAaC,KAAjC,GAAyC,KAAKC,UAAL,CAAgBP,UAAhB,CAAxD;MACH;;MACD,IAAI,CAACH,GAAG,CAACW,IAAJ,CAASC,MAAd,EAAsB;QAClB,OAAO,IAAP;MACH;IACJ,CAbG,EAaD,CAACZ,GAAD,EAAMC,MAAN,EAAcC,MAAd,EAAsBC,UAAtB,KAAqC;MACpC;MACA,IAAIU,GAAG,GAAGb,GAAG,CAACW,IAAJ,CAASC,MAAT,KAAoB,KAApB,GAA4B,CAA5B,GAAgCZ,GAAG,CAACQ,KAAJ,CAAUM,QAAV,CAAmBC,MAA7D;MACAf,GAAG,CAACQ,KAAJ,CAAUQ,kBAAV,GAA+BH,GAAG,GAAGb,GAAG,CAACQ,KAAJ,CAAUM,QAAV,CAAmBG,MAAnB,CAA0B,CAACC,CAAD,EAAIC,IAAJ,KAAa;QACxE,OAAOD,CAAC,GAAGC,IAAI,CAACC,MAAhB;MACH,CAFoC,EAElC,CAFkC,IAE7B,CAACP,GAAG,GAAG,CAAP,IAAY,KAAKQ,UAAL,CAAgBlB,UAAU,GAAG,CAA7B,CAFc,GAEoB,CAFtD;IAGH,CAnBG,EAmBD,IAnBC,EAmBK,CAnBL,CAAJ;EAoBH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIR,gBAAgB,GAAG;IACfT,IAAI,CAAC,KAAKW,IAAN,EAAY,IAAZ,EAAkB,CAACyB,IAAD,EAAOrB,MAAP,EAAeC,MAAf,EAAuBC,UAAvB,KAAsC;MACxD,IAAImB,IAAI,CAACC,QAAL,CAAcZ,IAAd,CAAmBC,MAAnB,IAA6BU,IAAI,CAACR,QAAlC,IAA8CQ,IAAI,CAACR,QAAL,CAAcC,MAAhE,EAAwE;QACpE,IAAIS,OAAO,GAAG,KAAKH,UAAL,CAAgBlB,UAAU,GAAG,CAA7B,CAAd,CADoE,CAEpE;;QACA,IAAIsB,GAAG,GAAGH,IAAI,CAACG,GAAL,GAAWH,IAAI,CAACF,MAAL,GAAc,CAAzB,GAA6BE,IAAI,CAACN,kBAAL,GAA0B,CAAjE;QACA,IAAIU,QAAQ,GAAGD,GAAG,GAAGD,OAArB;QACAF,IAAI,CAACR,QAAL,CAAca,OAAd,CAAuB3B,GAAD,IAAS;UAC3BA,GAAG,CAACyB,GAAJ,GAAUC,QAAV;UACAA,QAAQ,IAAI1B,GAAG,CAACoB,MAAJ,GAAaI,OAAzB;QACH,CAHD;MAIH;IACJ,CAXG,EAWD,IAXC,EAWK,IAXL,CAAJ;EAYH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACI5B,cAAc,GAAG;IACbV,IAAI,CAAC,KAAKW,IAAN,EAAY,IAAZ,EAAkB,CAACyB,IAAD,EAAOrB,MAAP,EAAeC,MAAf,EAAuBC,UAAvB,KAAsC;MACxD,IAAI,CAACmB,IAAI,CAACC,QAAL,CAAcZ,IAAd,CAAmBC,MAAxB,EAAgC;QAC5B;MACH,CAHuD,CAIxD;;;MACA,IAAIgB,UAAU,GAAGN,IAAI,CAACN,kBAAL,GAA0B,KAAKK,UAAL,CAAgBlB,UAAU,GAAG,CAA7B,IAAkC,CAA5D,GAAgEmB,IAAI,CAACF,MAAtF;;MACA,IAAIQ,UAAU,GAAG,CAAjB,EAAoB;QAChB,KAAKC,cAAL,CAAoBP,IAApB,EAA0BM,UAAU,GAAG,CAAvC;MACH;IACJ,CATG,EASD,IATC,EASK,IATL,CAAJ;EAUH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIC,cAAc,CAACP,IAAD,EAAOQ,SAAP,EAAkB;IAC5B,IAAIR,IAAI,CAACrB,MAAT,EAAiB;MACb,IAAI8B,YAAY,GAAGT,IAAI,CAACrB,MAAL,CAAYa,QAA/B;MACA,IAAIkB,KAAK,GAAGD,YAAY,CAACE,SAAb,CAAwBd,IAAD,IAAU;QACzC,OAAOA,IAAI,KAAKG,IAAhB;MACH,CAFW,CAAZ;MAGAS,YAAY,CAACJ,OAAb,CAAqB,CAACR,IAAD,EAAOe,MAAP,KAAkB;QACnC,IAAIf,IAAI,KAAKG,IAAT,IAAiBH,IAAI,CAACgB,iBAAL,EAArB,EAA+C;UAAC;UAC5C;QACH;;QACD,IAAIC,OAAO,GAAG,CAAd,CAJmC,CAKnC;;QACA,IAAIF,MAAM,GAAGF,KAAb,EAAoB;UAChBI,OAAO,GAAG,CAACN,SAAX;QACH,CAFD,MAEO,IAAII,MAAM,GAAGF,KAAb,EAAoB;UAAE;UACzBI,OAAO,GAAGN,SAAV;QACH;;QACDX,IAAI,CAACM,GAAL,IAAYW,OAAZ,CAXmC,CAYnC;;QACA,IAAIjB,IAAI,CAACL,QAAL,IAAiBK,IAAI,CAACL,QAAL,CAAcC,MAAnC,EAA2C;UACvC,KAAKsB,cAAL,CAAoBlB,IAAI,CAACL,QAAzB,EAAmC,KAAnC,EAA0CsB,OAA1C;QACH;MACJ,CAhBD,EALa,CAsBb;;MACA,KAAKP,cAAL,CAAoBP,IAAI,CAACrB,MAAzB,EAAiC6B,SAAjC;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;;;EACIQ,UAAU,CAAChB,IAAD,EAAOiB,KAAP,EAAc;IACpB,IAAIjB,IAAI,CAACR,QAAL,CAAcC,MAAd,IAAwB,CAA5B,EAA+B;MAC3B,OAAO,EAAP;IACH;;IACD,IAAI;MACAR,IADA;MAEAkB,GAFA;MAGAhB,KAHA;MAIAW,MAJA;MAKAoB;IALA,IAMAlB,IANJ;IAOAA,IAAI,CAACR,QAAL,CAAca,OAAd,CAAsB,CAACR,IAAD,EAAOa,KAAP,KAAiB;MACnC,IAAIS,EAAE,GAAGnB,IAAI,CAACnB,UAAL,KAAoB,CAApB,GAAwBI,IAAI,GAAGE,KAAK,GAAG,CAAvC,GAA2CF,IAAI,GAAGE,KAAP,GAAe+B,aAAnE;MACA,IAAIE,EAAE,GAAGjB,GAAG,GAAGL,MAAM,GAAG,CAAxB;MACA,IAAIuB,EAAE,GAAGxB,IAAI,CAACZ,IAAd;MACA,IAAIqC,EAAE,GAAGzB,IAAI,CAACM,GAAL,GAAWN,IAAI,CAACC,MAAL,GAAc,CAAlC;MACA,IAAIyB,IAAI,GAAG,EAAX;;MACA,IAAIvB,IAAI,CAACpB,MAAT,EAAiB;QACb2C,IAAI,GAAG,KAAKC,kBAAL,CAAwBL,EAAxB,EAA4BC,EAA5B,EAAgCC,EAAhC,EAAoCC,EAApC,CAAP;MACH,CAFD,MAEO;QACHC,IAAI,GAAG,KAAKE,eAAL,CAAqBN,EAArB,EAAyBC,EAAzB,EAA6BC,EAA7B,EAAiCC,EAAjC,CAAP;MACH;;MACDL,KAAK,CAACP,KAAD,CAAL,CAAagB,IAAb,CAAkBH,IAAlB;IACH,CAZD;EAaH;EAED;AACJ;AACA;AACA;AACA;;;EACII,eAAe,CAAC3B,IAAD,EAAO4B,GAAP,EAAY;IACvB,IAAI;MACAzC,KADA;MAEAW;IAFA,IAGAE,IAHJ;IAIA,IAAI;MACA6B,UADA;MAEAC;IAFA,IAGAF,GAAG,CAACG,SAAJ,EAHJ;IAIAH,GAAG,CAACI,SAAJ,CAAc7C,KAAK,GAAG0C,UAAtB,EAAkC/B,MAAM,GAAG,CAAT,GAAagC,UAA/C;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIG,oBAAoB,CAACjC,IAAD,EAAOkC,KAAP,EAAcC,KAAd,EAAqB;IACrC,IAAI;MAAEhC,GAAF;MAAOiC,MAAP;MAAeC,KAAf;MAAsBC,wBAAtB;MAAgDC;IAAhD,IAA6E,KAAKC,iBAAL,CAAuBxC,IAAvB,EAA6B,GAA7B,CAAjF;IACA,IAAImB,EAAE,GAAGkB,KAAK,GAAGC,wBAAjB;IACA,IAAIlB,EAAE,GAAGjB,GAAT;IACA,IAAIkB,EAAE,GAAGgB,KAAK,GAAGC,wBAAjB;IACA,IAAIhB,EAAE,GAAGc,MAAT;IACA,IAAIK,EAAE,GAAGtB,EAAE,GAAG,EAAd;IACA,IAAIuB,EAAE,GAAGtB,EAAE,GAAG,CAACE,EAAE,GAAGF,EAAN,IAAY,CAA1B;IACA,IAAIG,IAAI,GAAI,KAAIJ,EAAG,IAAGC,EAAG,MAAKqB,EAAG,IAAGC,EAAG,IAAGrB,EAAG,IAAGC,EAAG,EAAnD;IACAY,KAAK,CAACR,IAAN,CAAWH,IAAX;IACAY,KAAK,CAAClD,IAAN,GAAaoD,KAAK,GAAGE,wBAArB;IACAJ,KAAK,CAAChC,GAAN,GAAYA,GAAG,GAAG,CAACiC,MAAM,GAAGjC,GAAT,GAAegC,KAAK,CAACrC,MAAtB,IAAgC,CAAlD;EACH;;AArM+B;;AAwMpC,eAAehC,gBAAf"},"metadata":{},"sourceType":"module"}